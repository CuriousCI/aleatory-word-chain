/* */
// Vector *parse(wchar_t *str) {
//   Vector *words = vec();
//   Character state = SPECIAL;
//
//   String *token;
//   push(words, wchar_t_to_str(L'.'));
//
//   do {
//     wchar_t c = towlower(*str);
//
//     if (c == '\'') {
//       if (state == LETTER) {
//         append(token, c);
//         push(words, token->str);
//       }
//
//       state = SEPARATOR;
//     } else if (c == L'?' || c == L'!' || c == L'.') {
//       if (state == LETTER)
//         push(words, token->str);
//
//       push(words, wchar_t_to_str(c));
//       state = SPECIAL;
//     } else if (iswalpha(c) || iswdigit(c)) {
//       if (state == LETTER)
//         append(token, c);
//       else
//         token = wchar_t_to_string(c);
//
//       state = LETTER;
//     } else {
//       if (state == LETTER)
//         push(words, token->str);
//
//       state = SEPARATOR;
//     }
//
//     str++;
//   } while (*str);
//
//   return words;
// }



void _parse(wchar_t *str, void (*save)(wchar_t *)) {
  typedef enum { LETTER, SEPARATOR } Character;

  Character type = SEPARATOR;
  String *token;

  save(wchar_t_to_str(L'.'));

  do {
    wchar_t c = towlower(*str);

    int is_alpha = iswalpha(c) || iswdigit(c),
        is_special = c == L'?' || c == L'!' || c == L'.';

    if (type == LETTER) {
      if (is_alpha || c == '\'')
        append(token, c);
      if (!is_alpha)
        save(token->str);
    } else if (is_alpha)
      token = wchar_t_to_string(c);

    if (is_special)
      save(wchar_t_to_str(c));

    type = is_alpha ? LETTER : SEPARATOR;

  } while (*++str);
}



void _parse(wchar_t *str, void (*save)(wchar_t *)) {
  String *token;
  int is_word = 0;

  save(wctowcs(L'.'));

  do {
    wchar_t c = towlower(*str);

    int is_alphanumeric = iswalpha(c) || iswdigit(c),
        is_special = c == L'?' || c == L'!' || c == L'.';

    if (is_word) {
      if (is_alphanumeric || c == '\'')
        append(token, c);
      if (!is_alphanumeric)
        save(token->str);
    } else if (is_alphanumeric)
      token = wctostr(c);

    if (is_special)
      save(wctowcs(c));

    is_word = is_alphanumeric;
  } while (*++str);
}



// Link *link;
// for (int j = 0; links != NULL && j < links->size; j++) {
//   Vector *bucket = at(links, j);
//
//   for (int k = 0; bucket != NULL && k < bucket->len; k++) {
//     Entry *e = get(bucket, k);
//
//     Link *l = e->value;
//
//     if (total >= rng)
//       break;
//
//     total += l->frequency;
//     link = l;
//   }
// }

// fprintf(stderr, "%ld\n", bucket->len);
// fprintf(stderr, "BEFORE\n");
// fprintf(stderr, "AFTER\n");
// if (capitalize) {
//   ((wchar_t *)link->entry->key)[0] =
//       toupper(((wchar_t *)link->entry->key)[0]);
//   printf("%ls ", (wchar_t *)link->entry->key);
//   ((wchar_t *)link->entry->key)[0] =
//       tolower(((wchar_t *)link->entry->key)[0]);
//   capitalize = 0;
// }
// printf("%ls ", (wchar_t *)link->entry->key);
// TODO: fast concatenation and print at the end
// if (is_special(((wchar_t *)link->entry->key)[0]))
//   capitalize = 1;

// if (link != NULL)
//   links = link->entry->value;
// }


FINALE ------------------------------


// wchar_t *tail = string->str + string->len - 2;
// tail = (wchar_t[]){c, 0};

// int *array = calloc(2, sizeof(int));
// array = (int[]){10, 20};

// string->len = 1;
// string->str = calloc(string->len, sizeof(wchar_t));

// struct string_t *wctostr(wchar_t c) {
//     struct string_t *string = malloc(sizeof(struct string_t));
//
//     string->len = 2;
//     string->str = calloc(string->len, sizeof(wchar_t));
//     *(string->str) = c;
//
//     return string;
// }

// if (++string->len >= string->size) {
//   string->size++;
//   // string->size *= 2;
//   string->str = realloc(string->str, string->size * sizeof(wchar_t));
// }
// string->size = 2;

// string->str = realloc(string->str, ++string->len * sizeof(wchar_t));

// TODO: return -1 if error, or crash?
/* */
// String *str() {
//   String *string = malloc(sizeof(String));
//
//   string->len = 1;
//   // string->size = 1;
//   // string->str = calloc(string->size, sizeof(wchar_t));
//   string->str = calloc(string->len, sizeof(wchar_t));
//
//   return string;
// }

-----

/* */
// typedef struct String {
//   wchar_t *str;
//   size_t len;
// } String;

// TODO: returns -1 if ....

// typedef struct String {
//   wchar_t *str;
//   size_t len;
//   size_t size;
// } String;

/* Allocate a slice containing a single wchar_t. */
// wchar_t *t_to_str(wchar_t c);

/* Allocate a String containing a single wchar_t. */
// struct string_t *wctostr(wchar_t c);


VECTOR -----

// typedef struct Vector {
//   void **data;
//   size_t len;
//   size_t size;
// } Vector;

// // TODO: sistema questa struttura
// // TODO: generazione automatica documentazione dal codice?
//
// #include <stddef.h>
//
// // TODO: typedef void *Generic; ??
// // TODO: docstrings and attributes and examples?
// // TODO: encapsulate data
//
// /* A generic collection */
// typedef struct Vector {
//   void **data;
//   size_t len;
//   size_t size;
// } Vector;
//
// /* Allocate an empty Vector on the heap. */
// Vector *vec();
//
// // TODO: returns -1 if outside of array
// /* Returns the i-th element of the vector. */
// void *get(Vector *vector, size_t index);
//
// /* Pushes an item at the end of the Vector. */
// void push(Vector *vector, void *item);

VECTOR 2 -------

// Vector *vec() {
//   Vector *vector = calloc(1, sizeof(Vector));
//
//   vector->len = 0;
//   vector->size = 8;
//   vector->data = calloc(vector->size, sizeof(void *));
//
//   return vector;
// }
//
// // TODO: error handling
// void *get(Vector *vector, size_t index) { return vector->data[index]; }
//
// void push(Vector *vector, void *item) {
//   if (++vector->len >= vector->size) {
//     vector->size = vector->size * 2;
//     vector->data = realloc(vector->data, vector->size * sizeof(void *));
//   }
//   vector->data[vector->len - 1] = item;
// }

// Vector *vec() {
//   Vector *vector = calloc(1, sizeof(Vector));
//   vector->len = 0;
//   vector->data = calloc(vector->len, sizeof(void *));
//   return vector;
// }
//
// void *get(Vector *vector, size_t index) { return vector->data[index]; }
//
// void push(Vector *vector, void *item) {
//   vector->data = realloc(vector->data, ++vector->len * sizeof(void *));
//   vector->data[vector->len - 1] = item;
// }

// vector->size++;

MAP -------------------

// void *value(RBTree *tree, wchar_t *key, size_t size) {
//   Node *n = node(tree, key);
//
//   if (n->value == NULL)
//     n->value = calloc(1, size);
//
//   return n->value;
// }

// Node *node(RBTree *tree, wchar_t *key) {
//   Node *node = tree->root;
//   Node *parent = NULL;
//   int cmp;
//
//   while (node != FAKE_LEAF) {
//     parent = node;
//     cmp = wcscmp(key, node->key);
//
//     if (cmp == 0)
//       return node;
//
//     if (cmp < 0)
//       node = node->sx;
//     else
//       node = node->dx;
//   }
//
//   node = calloc(1, sizeof(Node));
//   *node = (Node){key, NULL, Red, FAKE_LEAF, FAKE_LEAF, parent};
//
//   push(tree->nodes, node);
//
//   if (parent == NULL) {
//     tree->root = node;
//     return node;
//   } else if (cmp < 0)
//     parent->sx = node;
//   else
//     parent->dx = node;
//
//   balance(tree, node);
//   return node;
// }
//
// void *value(RBTree *tree, wchar_t *key, size_t size) {
//   Node *n = node(tree, key);
//
//   if (n->value == NULL)
//     n->value = calloc(1, size);
//
//   return n->value;
// }

static void rotate_sx(struct map_t *map, struct entry_t *entry) {
    struct entry_t *parent = entry->parent, *right_child = entry->dx;

    entry->dx = right_child->sx;
    if (right_child->sx != NULL)
        right_child->sx->parent = entry;

    right_child->sx = entry;
    entry->parent = right_child;

    if (parent == NULL)
        map->root = right_child;
    else if (parent->sx == entry)
        parent->sx = right_child;
    else if (parent->dx == entry)
        parent->dx = right_child;

    if (right_child != NULL)
        right_child->parent = parent;
}

static void rotate_dx(struct map_t *map, struct entry_t *entry) {
    struct entry_t *parent = entry->parent, *left_child = entry->sx;

    entry->sx = left_child->dx;
    if (left_child->dx != NULL)
        left_child->dx->parent = entry;

    left_child->dx = entry;
    entry->parent = left_child;

    if (parent == NULL)
        map->root = left_child;
    else if (parent->sx == entry)
        parent->sx = left_child;
    else if (parent->dx == entry)
        parent->dx = left_child;

    if (left_child != NULL)
        left_child->parent = parent;
}

static void balance(struct map_t *map, struct entry_t *entry) {
    struct entry_t *parent = entry->parent;

    if (parent == NULL)
        return;

    if (parent->color == Black)
        return;

    struct entry_t *grandpa = parent->parent;

    if (grandpa == NULL) {
        parent->color = Black;
        return;
    }

    struct entry_t *uncle = grandpa->sx == parent ? grandpa->dx : grandpa->sx;

    if (uncle != NULL && uncle->color == Red) {
        parent->color = Black;
        grandpa->color = Red;
        uncle->color = Black;

        balance(map, grandpa);
    } else if (parent == grandpa->sx) {
        if (entry == parent->dx) {
            rotate_sx(map, parent);
            parent = entry;
        }
        rotate_dx(map, grandpa);
        parent->color = Black;
        grandpa->color = Red;
    } else {
        if (entry == parent->sx) {
            rotate_dx(map, parent);
            parent = entry;
        }
        rotate_sx(map, grandpa);
        parent->color = Black;
        grandpa->color = Red;
    }
}

// typedef struct Node {
//   wchar_t *key;
//   void *value;
//   // Color color;
//   char color;
//   struct Node *sx, *dx;
//   struct Node *parent;
// } Node;

// typedef struct RBTree {
//   Node *root;
//   Vector *nodes;
// } RBTree;

// Node *FAKE_LEAF = &(Node){NULL, NULL, Black, NULL, NULL, NULL};
//
// RBTree *tree() {
//   RBTree *tree = calloc(1, sizeof(RBTree));
//
//   *tree = (RBTree){FAKE_LEAF, vec()};
//
//   return tree;
// }
//
// typedef enum { Left, Right } Direction;
//
// static void rotate_sx(RBTree *tree, Node *node) {
//   Node *parent = node->parent;
//   Node *right_child = node->dx;
//
//   node->dx = right_child->sx;
//   if (right_child->sx != NULL)
//     right_child->sx->parent = node;
//
//   right_child->sx = node;
//   node->parent = right_child;
//
//   if (parent == NULL)
//     tree->root = right_child;
//   else if (parent->sx == node)
//     parent->sx = right_child;
//   else if (parent->dx == node)
//     parent->dx = right_child;
//
//   if (right_child != NULL)
//     right_child->parent = parent;
// }
//
// static void rotate_dx(RBTree *tree, Node *node) {
//   Node *parent = node->parent;
//   Node *left_child = node->sx;
//
//   node->sx = left_child->dx;
//   if (left_child->dx != NULL)
//     left_child->dx->parent = node;
//
//   left_child->dx = node;
//   node->parent = left_child;
//
//   if (parent == NULL)
//     tree->root = left_child;
//   else if (parent->sx == node)
//     parent->sx = left_child;
//   else if (parent->dx == node)
//     parent->dx = left_child;
//
//   if (left_child != NULL)
//     left_child->parent = parent;
// }
//
// static void balance(RBTree *tree, Node *node) {
//   Node *parent = node->parent;
//
//   if (parent == NULL)
//     return;
//
//   if (parent->color == Black)
//     return;
//
//   Node *grandpa = parent->parent;
//
//   if (grandpa == NULL) {
//     parent->color = Black;
//     return;
//   }
//
//   Node *uncle = grandpa->sx == parent ? grandpa->dx : grandpa->sx;
//
//   if (uncle != NULL && uncle->color == Red) {
//     parent->color = Black;
//     grandpa->color = Red;
//     uncle->color = Black;
//
//     balance(tree, grandpa);
//   } else if (parent == grandpa->sx) {
//     if (node == parent->dx) {
//       rotate_sx(tree, parent);
//       parent = node;
//     }
//     rotate_dx(tree, grandpa);
//     parent->color = Black;
//     grandpa->color = Red;
//   } else {
//     if (node == parent->sx) {
//       rotate_dx(tree, parent);
//       parent = node;
//     }
//     rotate_sx(tree, grandpa);
//     parent->color = Black;
//     grandpa->color = Red;
//   }
// }
//
// Node *node(RBTree *tree, wchar_t *key) {
//   Node *node = tree->root;
//   Node *parent = NULL;
//   int cmp;
//
//   while (node != FAKE_LEAF) {
//     parent = node;
//     cmp = wcscmp(key, node->key);
//
//     if (cmp == 0)
//       return node;
//
//     if (cmp < 0)
//       node = node->sx;
//     else
//       node = node->dx;
//   }
//
//   node = calloc(1, sizeof(Node));
//   *node = (Node){key, NULL, Red, FAKE_LEAF, FAKE_LEAF, parent};
//
//   push(tree->nodes, node);
//
//   if (parent == NULL) {
//     tree->root = node;
//     return node;
//   } else if (cmp < 0)
//     parent->sx = node;
//   else
//     parent->dx = node;
//
//   balance(tree, node);
//   return node;
// }
//
// void *value(RBTree *tree, wchar_t *key, size_t size) {
//   Node *n = node(tree, key);
//
//   if (n->value == NULL)
//     n->value = calloc(1, size);
//
//   return n->value;
// }
// void *value(RBTree *tree, wchar_t *key, size_t size) {
//   Node *n = node(tree, key);
//
//   if (n->value == NULL)
//     n->value = calloc(1, size);
//
//   return n->value;
// }

// Node *node(RBTree *tree, wchar_t *key) {
//   Node *node = tree->root;
//   Node *parent = NULL;
//   int cmp;
//
//   while (node != FAKE_LEAF) {
//     parent = node;
//     cmp = wcscmp(key, node->key);
//
//     if (cmp == 0)
//       return node;
//
//     if (cmp < 0)
//       node = node->sx;
//     else
//       node = node->dx;
//   }
//
//   node = calloc(1, sizeof(Node));
//   *node = (Node){key, NULL, Red, FAKE_LEAF, FAKE_LEAF, parent};
//
//   push(tree->nodes, node);
//
//   if (parent == NULL) {
//     tree->root = node;
//     return node;
//   } else if (cmp < 0)
//     parent->sx = node;
//   else
//     parent->dx = node;
//
//   balance(tree, node);
//   return node;
// }
//
// void *value(RBTree *tree, wchar_t *key, size_t size) {
//   Node *n = node(tree, key);
//
//   if (n->value == NULL)
//     n->value = calloc(1, size);
//
//   return n->value;
// }


// typedef struct Node {
//   wchar_t *key;
//   void *value;
//   // Color color;
//   char color;
//   struct Node *sx, *dx;
//   struct Node *parent;
// } Node;

// typedef struct RBTree {
//   Node *root;
//   Vector *nodes;
// } RBTree;

// Node *FAKE_LEAF = &(Node){NULL, NULL, Black, NULL, NULL, NULL};
//
// RBTree *tree() {
//   RBTree *tree = calloc(1, sizeof(RBTree));
//
//   *tree = (RBTree){FAKE_LEAF, vec()};
//
//   return tree;
// }
//
// typedef enum { Left, Right } Direction;
//
// static void rotate_sx(RBTree *tree, Node *node) {
//   Node *parent = node->parent;
//   Node *right_child = node->dx;
//
//   node->dx = right_child->sx;
//   if (right_child->sx != NULL)
//     right_child->sx->parent = node;
//
//   right_child->sx = node;
//   node->parent = right_child;
//
//   if (parent == NULL)
//     tree->root = right_child;
//   else if (parent->sx == node)
//     parent->sx = right_child;
//   else if (parent->dx == node)
//     parent->dx = right_child;
//
//   if (right_child != NULL)
//     right_child->parent = parent;
// }
//
// static void rotate_dx(RBTree *tree, Node *node) {
//   Node *parent = node->parent;
//   Node *left_child = node->sx;
//
//   node->sx = left_child->dx;
//   if (left_child->dx != NULL)
//     left_child->dx->parent = node;
//
//   left_child->dx = node;
//   node->parent = left_child;
//
//   if (parent == NULL)
//     tree->root = left_child;
//   else if (parent->sx == node)
//     parent->sx = left_child;
//   else if (parent->dx == node)
//     parent->dx = left_child;
//
//   if (left_child != NULL)
//     left_child->parent = parent;
// }
//
// static void balance(RBTree *tree, Node *node) {
//   Node *parent = node->parent;
//
//   if (parent == NULL)
//     return;
//
//   if (parent->color == Black)
//     return;
//
//   Node *grandpa = parent->parent;
//
//   if (grandpa == NULL) {
//     parent->color = Black;
//     return;
//   }
//
//   Node *uncle = grandpa->sx == parent ? grandpa->dx : grandpa->sx;
//
//   if (uncle != NULL && uncle->color == Red) {
//     parent->color = Black;
//     grandpa->color = Red;
//     uncle->color = Black;
//
//     balance(tree, grandpa);
//   } else if (parent == grandpa->sx) {
//     if (node == parent->dx) {
//       rotate_sx(tree, parent);
//       parent = node;
//     }
//     rotate_dx(tree, grandpa);
//     parent->color = Black;
//     grandpa->color = Red;
//   } else {
//     if (node == parent->sx) {
//       rotate_dx(tree, parent);
//       parent = node;
//     }
//     rotate_sx(tree, grandpa);
//     parent->color = Black;
//     grandpa->color = Red;
//   }
// }
//
// Node *node(RBTree *tree, wchar_t *key) {
//   Node *node = tree->root;
//   Node *parent = NULL;
//   int cmp;
//
//   while (node != FAKE_LEAF) {
//     parent = node;
//     cmp = wcscmp(key, node->key);
//
//     if (cmp == 0)
//       return node;
//
//     if (cmp < 0)
//       node = node->sx;
//     else
//       node = node->dx;
//   }
//
//   node = calloc(1, sizeof(Node));
//   *node = (Node){key, NULL, Red, FAKE_LEAF, FAKE_LEAF, parent};
//
//   push(tree->nodes, node);
//
//   if (parent == NULL) {
//     tree->root = node;
//     return node;
//   } else if (cmp < 0)
//     parent->sx = node;
//   else
//     parent->dx = node;
//
//   balance(tree, node);
//   return node;
// }
//
// void *value(RBTree *tree, wchar_t *key, size_t size) {
//   Node *n = node(tree, key);
//
//   if (n->value == NULL)
//     n->value = calloc(1, size);
//
//   return n->value;
// }


ENCODER -------

// wchar_t *question, *exclamation, *dot;
// *parser = (struct parser_t){str, NULL, false, wctowcs(L'?'), wctowcs(L'!'), wctowcs(L'.')};

// static struct parser_t {
//     wchar_t *str, *token;
//     bool is_word;
// } parser_t;

// struct parser_t *parser(wchar_t *str) {
//     struct parser_t *parser = calloc(1, sizeof(struct parser_t *));
//     *parser = (struct parser_t){str, str, false};
//     return parser;
// }

// TODO: parser must not be null
// wchar_t *parse(struct parser_t *parser) {

//   wchar_t *text = str;
//   size_t token = 0, index = 0;
//   int is_word = 0;
//
//   wchar_t *q = wctowcs(L'?'), *e = wctowcs(L'!'), *d = wctowcs(L'.');
//
//   save(object, d);
//
//   do {
//     wchar_t c = *str;
//     int is_alpha = iswalpha(c) || iswdigit(c);
//
//     if (is_alpha)
//       *str = towlower(*str);
//
//     if (is_word) {
//       if (!is_alpha) {
//         save(object, text + token);
//         *str = 0;
//       }
//     } else if (is_alpha)
//       token = index;
//
//     if (c == L'?')
//       save(object, q);
//     if (c == L'!')
//       save(object, e);
//     if (c == L'.')
//       save(object, d);
//
//     is_word = is_alpha;
//     index++;
//   } while (*++str);

// Node *node = get(counter->nodes, i);
// wprintf(L"%ls", node->key);
//
// Word *word = node->value;
// RBTree *adjacent = word->adjacent;
//
// for (size_t j = 0; j < adjacent->nodes->len; j++) {
//     Node *next = get(adjacent->nodes, j);
//     wprintf(L",%ls,%g", next->key,
//             (float)((size_t)next->value) / (float)word->count);
// }
//
// wprintf(L"\n");

// void *get_value(struct entry_t *entry);
// void *get_key(struct entry_t *entry);
// void *set_value(struct entry_t *entry);
// void *set_key(struct entry_t *entry);

// void generic_parse(wchar_t *str, void *object,
//                    void (*save)(void *, wchar_t *)) {
//   wchar_t *text = str;
//   size_t token = 0, index = 0;
//   int is_word = 0;
//
//   wchar_t *q = wctowcs(L'?'), *e = wctowcs(L'!'), *d = wctowcs(L'.');
//
//   save(object, d);
//
//   do {
//     wchar_t c = *str;
//     int is_alpha = iswalpha(c) || iswdigit(c);
//
//     if (is_alpha)
//       *str = towlower(*str);
//
//     if (is_word) {
//       if (!is_alpha) {
//         save(object, text + token);
//         *str = 0;
//       }
//     } else if (is_alpha)
//       token = index;
//
//     if (c == L'?')
//       save(object, q);
//     if (c == L'!')
//       save(object, e);
//     if (c == L'.')
//       save(object, d);
//
//     is_word = is_alpha;
//     index++;
//   } while (*++str);
//   // TODO: apostrofi
// }

// Vector *parse(wchar_t *str) {
//   Vector *words = vec();
//
//   wchar_t *text = str;
//   size_t token = 0, counter = 0;
//   int is_word = 0;
//
//   wchar_t *q = wctowcs(L'?'), *e = wctowcs(L'!'), *d = wctowcs(L'.');
//
//   push(words, d);
//
//   do {
//     wchar_t c = *str;
//     int is_alpha = iswalpha(c) || iswdigit(c);
//
//     if (is_alpha)
//       *str = towlower(*str);
//
//     if (is_word) {
//       if (!is_alpha) {
//         push(words, text + token);
//         *str = 0;
//       }
//     } else if (is_alpha)
//       token = counter;
//
//     if (c == L'?')
//       push(words, q);
//     if (c == L'!')
//       push(words, e);
//     if (c == L'.')
//       push(words, d);
//
//     is_word = is_alpha;
//     counter++;
//   } while (*++str);
//
//   // TODO: apostrofi
//
//   return words;
// }

// typedef struct Word {
//   size_t count;
//   RBTree *adjacent;
// } Word;

// How to get input? Output should be (void *object, void(*save)(void *, wchar_t
// *))
// count parola per parola, oppure count dal file?
// in single process case read pointers
// in multi-process case read words
// in both read words

// RBTree *generic_count(FILE *file) {
//   // TODO: l'ultima parola punta alla prima
//   RBTree *words_counter = tree();
//   wchar_t *current = NULL, *next = NULL;
//
//   while (!current)
//     fwscanf(file, L"%ls", &current);
//
//   while (1) {
//     fwscanf(file, L"%ls", &next);
//
//     Word *counter = value(words_counter, current, sizeof(Word));
//     counter->count++;
//
//     if (counter->adjacent == NULL)
//       counter->adjacent = tree();
//
//     Node *count = node(counter->adjacent, next);
//     count->value++;
//
//     current = next;
//   }
//
//   return words_counter;
// }
//

// static struct line {
//   size_t count;
//   RBTree *adj;
// } line;

// void generic_count(wchar_t *current, wchar_t *next, RBTree *counter) {
//   struct line *l = value(counter, current, sizeof(line));
//   l->count++;
//
//   if (l->adj == NULL)
//     l->adj = tree();
//
//   Node *count = node(l->adj, next);
//   count->value++;
// }

// Instead of getting the words, gets' two words,
// Then gets the RBTreeMap struct (maybe rbtree_map?)
// adds the item to the rbtree_map
/* */
// RBTree *count(Vector *words) {
//   // TODO: l'ultima parola punta alla prima
//   RBTree *counter = tree();
//   size_t index = 0;
//
//   while (index < words->len - 1) {
//     wchar_t *current = get(words, index);
//     wchar_t *next = get(words, ++index);
//
//     Word *word = value(counter, current, sizeof(Word));
//     word->count++;
//
//     if (word->adjacent == NULL)
//       word->adjacent = tree();
//
//     Node *count = node(word->adjacent, next);
//     count->value++;
//   }
//
//   return counter;
// }

// gets a line, or maybe just the actual values:
//     - a word
//     - it's count
//         - the next words (maybe an array ? )
//         - the count for each
// void generic_save(RBTree *counter, FILE *file) {
//   for (size_t i = 0; i < counter->nodes->len; i++) {
//     Node *node = get(counter->nodes, i);
//     fwprintf(file, L"%ls", node->key);
//
//     Word *word = node->value;
//     RBTree *adjacent = word->adjacent;
//
//     for (size_t j = 0; j < adjacent->nodes->len; j++) {
//       Node *next = get(adjacent->nodes, j);
//       // TODO: %f instead of %g? I already account for scientific notation
//       now
//       // that I think about it!
//       fwprintf(file, L",%ls,%g", next->key,
//                (float)((size_t)next->value) / (float)word->count);
//     }
//
//     fwprintf(file, L"\n");
//   }
// }

/* */
// void save(RBTree *counter) {
//   for (size_t i = 0; i < counter->nodes->len; i++) {
//     Node *node = get(counter->nodes, i);
//     wprintf(L"%ls", node->key);
//
//     Word *word = node->value;
//     RBTree *adjacent = word->adjacent;
//
//     for (size_t j = 0; j < adjacent->nodes->len; j++) {
//       Node *next = get(adjacent->nodes, j);
//       wprintf(L",%ls,%g", next->key,
//               (float)((size_t)next->value) / (float)word->count);
//     }
//
//     wprintf(L"\n");
//   }
// }

// void save_(Map *counter, FILE *file) {
//   Entry *entry;
//   while (next(&entry, counter) != NULL) {
//     fwprintf(file, L"%ls", key(entry));
//     Map *adjacent = value(entry).adjacent;
//
//     Entry *word;
//     while (next(&word, adjacent) != NULL) {
//       fwprintf(file, L",%ls,%g", key(word),
//                (float)value(word) / (float)value(word).count);
//       word = next(word)
//     }
//
//     fwprintf(file, L"\n");
//     entry = next(entry);
//   }
// }

// ---

// #include <uchar.h>
// int is_alpha = UCHAR_ISALPHA(c) || iswdigit(c),
// get input from file, save to file
// parser struct, with is_word, token and index, L'?', L'!' and L'.'
//    - returns a single word, the next word
//    - while not null { parse(&str, &context) }
//    - it doesn't even need the token


















    if (csv && !parallel) {
        struct vec_t *words = vec();
        struct map_t *counter = map();
        struct iter_t *it;
        char *previous, *subsequent;

        while ((wc = getwc(in)) != (int)WEOF && !ferror(in))
            /* Add character to token. */
            switch (tokenize(wc, &token, &punctuation)) {
                case -1:
                    perror("tokenize");
                    exit(EXIT_FAILURE);
                default:
                    /* If WC generated a valid token, adds it to WORDS. */
                    if (token != NULL && push(words, token) == -1) {
                        perror("push word to vec of words");
                        exit(EXIT_FAILURE);
                    }

                    /* If WC generated a valid punctuation, adds it to WORDS. */
                    if (punctuation != NULL && push(words, punctuation) == -1) {
                        perror("push punctuation to vec of words");
                        exit(EXIT_FAILURE);
                    }
            }

        /* The last word is followed by the first word. */
        if ((it = iter(words)) == NULL && push(words, next(it)) == -1) {
            perror("error inserting first word at the end");
            exit(EXIT_FAILURE);
        }

        /* Iterator over words. */
        if ((it = iter(words)) == NULL) {
            perror("error generating iterator over words");
            exit(EXIT_FAILURE);
        }

        /* First word in text. */
        previous = next(it);

        /* Iterate words in text, and count their relative frequencies. */
        while ((subsequent = next(it))) {
            count(counter, previous, subsequent);
            previous = subsequent;
        }

        it = iter_map(counter);
        struct entry_t *entry;
        while ((entry = next(it))) {
            struct iter_t *subsequents;
            struct entry_t *subsequent;
            counter_t *counter;

            fprintf(out, "%s", key(entry));

            counter = value(entry);
            subsequents = iter_map(counter->words);
            while ((subsequent = next(subsequents)))
                fprintf(
                    out,
                    ",%s,%g",
                    key(subsequent),
                    (float)*(size_t *)value(subsequent) / (float)counter->count
                );
            fprintf(out, "\n");
        }

        exit(EXIT_SUCCESS);
    }













#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <wchar.h>

#include "csv.h"
#include "map.h"
#include "string.h"
#include "vec.h"

/* TODO: err, verr, warn vwarn */

/* Prints the error and exits with failure. */
void panic(char *error) {
    if (errno == 0)
        fprintf(stderr, "%s", error);
    else
        perror(error);

    exit(EXIT_FAILURE);
}

/* Reads INPUT one UNICODE character at a time, splits the text into TOKENS with TOKENIZE, and processes each TOKEN with COLLECT.  */
void split(FILE *stream, void *collection, int (*collect)(void *, char *, int)) {
    wchar_t wc;
    int len, flen;
    char *tokens[2], *first;

    while (!feof(stream)) {
        wc = getwc(stream);

        if (ferror(stream))
            panic("input file reading error");

        if ((len = tokenize(wc, tokens)) == -1)
            panic("tokenize failed");

        for (size_t token = 0; token < 2; token++)
            if (tokens[token]) {
                if (first == NULL) {
                    first = tokens[token];
                    flen = len;
                }

                if (collect(collection, tokens[token], len) == -1)
                    panic("error adding token to container!");
            }
    }

    if (collect(collection, first, flen) == -1)
        panic("error adding token to container!");
}

int write_to_pipe(void *pipefd, char *word, int len) {
    return write(*(int *)pipefd, word, len);
}

int push_to_vec(void *vec, char *word, int len) {
    return push((struct vec_t *)vec, word);
}

void cnt(struct map_t *counter, void *collection, char *(*token)(void *)) {
    char *word = token(collection), *next;

    while ((next = token(collection))) {
        count(counter, word, next);
        word = next;
    }
}

char *tkn_pipe(void *pipefd) {
    return NULL;
}

char *tkn_vec(void *iter) {
    return NULL;
}

int main() {
    pid_t pid = 0;
    int parallel = 0;
    FILE *in = stdin, *out = stdout;
    struct vec_t *words = vec();
    struct map_t *counter = map();
    struct iter_t *it;
    char *previous, *subsequent;
    int pipefd[2]; /*  0 - reader, 1 - writer */

    /* Create process to read input. */
    if (parallel && (pid = fork()) == -1)
        panic("fork");

    /* Reads input and splits the words. */
    if (pid == 0) {
        if (parallel) {
            split(in, &pipefd[1], write_to_pipe);
            exit(EXIT_SUCCESS);
        } else
            split(in, words, push_to_vec);
    }

    /* Create process to count words. */
    if (parallel && (pid = fork()) == -1)
        panic("fork");

    if (pid == 0) {
        if (parallel) {
            cnt(counter, &pipefd[0], tkn_pipe);
            exit(EXIT_SUCCESS);
        } else {
            it = iter(words);
            cnt(counter, it, tkn_vec);
        }
    }

    /* Third process */

    it = iter_map(counter);
    struct entry_t *entry;
    while ((entry = next(it))) {
        struct iter_t *subsequents;
        struct entry_t *subsequent;
        counter_t *counter;

        fprintf(out, "%s", key(entry));

        counter = value(entry);
        subsequents = iter_map(counter->words);
        while ((subsequent = next(subsequents)))
            fprintf(
                out,
                ",%s,%g",
                key(subsequent),
                (float)*(size_t *)value(subsequent) / (float)counter->count
            );
        fprintf(out, "\n");
    }

    exit(EXIT_SUCCESS);
}

































#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
    pid_t pid;

    pid = fork();

    if (pid == 0) {
        /* figlio fa roba */
        /* figlio legge input */
        exit(EXIT_SUCCESS);
    }

    // padre

    pid = fork();

    if (pid == 0) {
        /* secondo figlio fa roba */
        /* figlio inserisce in struttura */
        exit(EXIT_SUCCESS);
    }

    {
        // padre fa roba
        // padre salva i dati
    }
}
